# چالش‌های الگوریتمی و داده‌ساختارها

def find_two_sum(nums, target):
    num_dict = {}
    for num in nums:
        complement = target - num
        if complement in num_dict:
            return (complement, num)
        num_dict[num] = True

# زمان: O(n)
# در این تابع، لیست nums یک بار پیمایش می‌شود.
# برای هر عدد، بررسی می‌شود که آیا مکمل آن (عدد هدف منهای آن عدد) در num_dict وجود دارد.
# این جستجو در دیکشنری به طور میانگین O(1) زمان می‌برد.
# بنابراین، کل زمان اجرای این تابع O(n) است.


# فضا: O(n)
# در بدترین حالت، اگر هیچ دو عددی مجموع مورد نظر را نداشته باشند، تمام اعداد در دیکشنری ذخیره می‌شوند.
# بنابراین، فضای مورد نیاز O(n) خواهد بود.


# طراحی سیستم کوچک (مدیریت لیست‌های انجام کار)
# در پیاده‌سازی سیستم مدیریت لیست‌های انجام کار، کدهایی مانند افزودن، حذف و ویرایش وظایف وجود دارند.
def add_task(request):
    if request.method == "POST":
        title = request.POST.get('title')
        Task.objects.create(user=request.user, title=title)
        return redirect('task_list')
# تحلیل زمان
# زمان افزودن وظیفه
# ایجاد یک رکورد جدید در پایگاه داده معمولاً زمان ثابت O(1) خواهد داشت، اما اگر پایگاه داده بزرگ باشد و نیاز به ایندکس‌گذاری داشته باشد، ممکن است زمان بیشتری صرف شود.


# تحلیل فضا
# فضا
# هر بار که یک وظیفه جدید ایجاد می‌شود، به فضای ذخیره‌سازی پایگاه داده اضافه می‌شود، اما این فضا به صورت مداوم افزایش می‌یابد و به تعداد وظایف بستگی دارد.


# طراحی API
# تحلیل زمان و فضا
# در طراحی API با استفاده از Django Rest Framework، برای هر عملیات (افزودن، حذف، به‌روزرسانی و خواندن) زمان و فضای مشابهی داریم:
#
# زمان هر عملیات: O(1) برای افزودن و O(n) برای خواندن (اگر تمام وظایف را بخواهیم) به دلیل پیمایش در نتایج.
# فضا: O(n) برای نگهداری وظایف در پایگاه داده.

